select sysdate from dual;
/
create table emp_Test (
emp_id number primary key,
emp_name varchar(20),
emp_salary decimal(10,2)
);
desc emp_Test;
-------------------------
INSERT STATEMENT
--------------------
insert into emp_Test VALUES(1,'Ahmad',40000);
/
select * from emp_Test;
/
insert into emp_Test VALUES(2,'Raj',45000);
insert into emp_Test VALUES(3,'Mohan',50000);
insert into emp_Test VALUES(4,'Rohan',60000);
/
select * from emp_Test where emp_id=1;
/
select * from emp_Test where emp_salary>40000;
/
UPDATE STATEMENT
/
UPDATE emp_Test
SET emp_salary='70000'
WHERE EMP_ID=1;
/
DELETE SINGLE RECORD DELETE MORE THAN ONE RECORD DELETED
/
DELETE FROM EMP_TEST
WHERE EMP_ID=1;
/

TRUNCATE TABLE STATEMENT
------------------------
THE TRUNCATE TABLE STATEMENT REMOVES ALL THE ROWS FROM A TABLE MORE QUICKLY THAN A DELETE.
LOGICALLY,TRUNCATE TABLE IS SIMILAR TO THE DELETE STATEMENT WITH NO WHERE CLOUSE.
SYNTAX
------
TRUNCATE TABLE TABLE_NAME
NOT USED WHERE CLOUSE.

TRUNCATE TABLE EMP_TEST;
DELETE ALL RECORD OK

DROP TABLE STATEMENT
--------------------
THE DROP TABLE REMOVES ONE OR MORE TABLES
SYNTAX
DROP TABLE TABLE1_NAME,TABLE2_NAME,....;
/
DROP TABLE EMP_TEST;

ORDER BY CLOUSE
--------------
THE ORDER BY CLOUSE IS USE TO SORT THE DATA RETURNED BY A QUERY IN ASCENDING AND DESCENDING ORDER
THE BASIC SYNTAX IS 

SELECT CLUMN_LIST FROM TABLE_NAME ORDER BY COLUMN_NAME ASC|DESC;
/
SELECT WALI QUERY ME USE KRTE HAI ORDER BY CLOUSE
/
ASC --LOWEST TO HIGHEST
DESC-- HIGHEST TO LOWEST

SELECT * FROM EMP_TEST ORDER BY EMP_ID DESC;
SELECT * FROM EMP_TEST ORDER BY EMP_ID ASC;
/
SELECT EMP_NAME FROM EMP_TEST ORDER BY EMP_ID ASC;

DISTINCT CLOUSE
---------------
THE DISTINCT CLOUSE IS USE TO REMOVE DUPLICATE ROW FROM THE RESULT SET 
IT MEANS MAN LO AAPKA COLUMN ME RUHAN RUHAN TWO TIME HAI DISTINCT LAGANE
SE EK NAME SHOW KAREGA IN COLUMN ME
SYNTAX
SELECT DISTINCT COLUMN_LIST FROM TABLE_NAME;
/
SELECT DISTINCT EMP_NAME FROM EMP_TEST;
SELECT DISTINCT EMP_ID,EMP_NAME FROM EMP_TEST;
/
TABLE RELATIONSHIP
-----------------
A TABLE RELATIONSHIP IS ESTABLISHED WHEN A CHILD TABLE DEFINES A FOEGIEN KEY COLUMN THAT REFERENCE
THE PRIMARY KEY COLUMN OF ITS PARENT TABLE
-- ONE TO ONE
ONE RECORD IN A TABLE IS ASSOCIATED WITH ONE AND ONLY ONE RECORD
-- ONE TO MANY
ONE RECORD IN A TABLE CAN BE ASSOCIATED WITH ONE OR MORE RECORDS IN ANOTHERS TABLE
-- MANY TO MANY
MULTIPLE RECORDS IN A TABLE ASSOCIATED WITH MULTIPLE RECORD IN ANOTHERS TABLE.
/
CREATE TABLE DEPT_TEST(
DEPT_ID INT NOT NULL PRIMARY KEY,
DEPT_NAME VARCHAR2(50)
);
/
CREATE TABLE EMPP_DEPT (
EMP_ID INT NOT NULL PRIMARY KEY,
EMP_NAME VARCHAR2(20),
EMP_SALARY DECIMAL(10,2),
DEPT_ID INT
);
/
INSERT INTO DEPT_TEST VALUES(1,'IT');
INSERT INTO DEPT_TEST VALUES(2,'HR');
INSERT INTO DEPT_TEST VALUES(3,'MEDICAL');
INSERT INTO DEPT_TEST VALUES(4,'QUALITY');
/
INSERT INTO EMPP_DEPT VALUES(1,'AHMAD',40000,1); 
INSERT INTO EMPP_DEPT VALUES(2,'MARK',35000,2);
INSERT INTO EMPP_DEPT VALUES(3,'ABID',50000,2);
INSERT INTO EMPP_DEPT VALUES(4,'RAHUL',45000,1);
/
AND & OR OPERATORS
------------------
AND OPERATOR
THE AND OPERATOR IS A LOGICAL OPERATOR THA COMBINES TWO CONDITIONS AND RETURN
TRUE ONLY IF BOTH CONDITION EVALUATE TO TRUE
THE AND OPERATOR IS OFTEN USED IN THE WHERE CLOUSE OF THE SELECT,UPDATE,DELETE STATEMENT
TO FORM CONDITIONS TO FILTER THE RESULT SET

SYNTAX
-------
SELECT COLUMN1_NAME,COLUMN2_NMAE.......COLUMNN_NAME FROM TABLE_NAME
WHERE CONDITION1 AND CONDITION2;
/
SELECT * FROM EMPP_DEPT;
/
SELECT * FROM EMPP_DEPT WHERE EMP_SALARY >35000 AND DEPT_ID=1;
/
OR OPERATOR IS ALSO A LOGICAL OPERATOR THAT COMBINES TWO CONDITIONS, BUT IT RETURN TRUE WHEN EITHR OF THE CONDITION IS TRUE
SELECT * FROM EMPP_DEPT WHERE EMP_SALARY >35000 OR DEPT_ID=1;
SELECT * FROM EMPP_DEPT WHERE EMP_SALARY >35000 AND (DEPT_ID=1 OR DEPT_ID=2);
/
IN OPERATOR
------------
THE IN OPERATOR IS A LOGICAL OPERATOR AND CHECKS A VALUE WITHIN A SET OF VALUES AND RETRIVE THE ROW/RECORD 
FROM THE TABLE WHICH ARE MATCHING
SYNTAX-----
SELECT COLUMN_LIST FROM TABLE_NAME
WHERE COLUMN_NAME IN (VALUE1,VALUE2,.....);
/
IN OPERATOR HUMESHA SELECT STATEMENT ME USED HOTE HAI
SELECT * FROM EMPP_DEPT; 
/
SELECT * FROM EMPP_DEPT WHERE DEPT_ID IN (1,3);
SELECT * FROM EMPP_DEPT WHERE EMP_NAME IN ('AHMAD','RAHUL');

BETWEEN OPERATOR
----------------
THE BETWEEN OPERATOR SELECTS VALUES WITHIN A GIVEN RANGE.THE VALUES CAN 
BE NUMBERS ,TEXT OR DATES

SYNTAX
------
SELECT COLUMN1_NMAE,COLUMN2_NAME....COLUMNN_NAME
FROM TABLE_NAME WHERE
COLUMN_NAME BTEWEEN MIN_VALUE AND MAX_VALUE;
/
SELECT * FROM EMPP_DEPT WHERE EMP_SALARY BETWEEN 35000 AND 50000;
/
LIKE OPERATOR
--------------
THE LIKE OPERATOR IS USED IN A WHERE CLOUSE TO SEARCH FOR A SPECIFIED PATTRN IN A COLUMN

THERE ARE TWO WILDCARDS OFTEN USED IN CONJUNCTION WITH THE LIKE OPERATOR.
1. THE PERCENT SIGN (%) REPRESENTS ZERO,ONE,OR MULTIPLE CHARACTERS
2. THE UNDERSCORE(_) REPRESENTS ONE,SINGLE CHARACTERS

SELECT * FROM EMPP_DEPT WHERE EMP_NAME LIKE 'A%';

SELECT * FROM EMPP_DEPT WHERE EMP_NAME LIKE '%A%';
SELECT * FROM EMPP_DEPT WHERE EMP_NAME LIKE '_A%';
SELECT * FROM EMPP_DEPT WHERE EMP_NAAME LIKE '--A%';
AAHMAD _ _ IGNORE THIS LINE
/
UNION OPERATOR
--------------
THE UNION OPERATOR IS USED TO COMBINE THE RESULTS OF TWO OR MORE SELECT QUERIES INTO A SINGLE RESULT SET.
COMBINES TWO OR MORE QUERIES AND REMOVES THE DUPLICATES
THE UNION OPERATION CREATE A NEW TABLE BY PLACING ALL ROWS FROM TWO
SOURCE TABLE INTO A SINGLE RESULT TABLE.

BASICS RULE
-----------
1. THE NUMBER AND THE ORDER OF THE COLUMNS MUST BE THE SAME IN ALL QUERIES
2. THE COLUMN MUST ALSO HAVE SIMILAR DATA TYPES

SYNTAX
------
SELECT COLUMN_LIST FROM TABLE_NAME
UNION SELECT COLUMN_LIST FROM TABLE2_NAME;
/
SELECT DEPT_ID FROM EMPP_DEPT
UNION
SELECT DEPT_ID FROM DEPT_TEST; 
/
SELECT DEPT_ID FROM EMPP_DEPT
UNION ALL 
SELECT DEPT_ID FROM DEPT_TEST ORDER BY DEPT_ID; 
/
COLUMN ALIAS
-----------
COLUMN ALIAS IS USED TO GIVE A TEMPORARY NAME FOR A COLUMN IN A TABLE.
ALIAS ARE OFTEN USED TO MAKE COLUMN NAMES READABLE.

SELECT * FROM EMPP_DEPT;
SELECT EMP_ID "ID" ,EMP_NAME "NAME" FROM EMPP_DEPT; 
/
"ID" THIS IS TEMPORARY COLUMN/
/
TABLE ALIAS
----------
THE USE OF TABLE ALIASES IS TO RENAME A TABLE IN A SPECIFIC SQL STATEMENT.

THE RENAMING IS A TEMPORARY CHANGE AND THE ACTUAL TABLE NAME DOES NOT CHANGE IN THE DATABASE.
/
USE WHEN JOIN TWO TABLE THEN USE THE TABLE ALIAS
JO QUERY HOTE HAI USSE SMALL KRTE HAI LIKE
TABLE NAME IS JITENDRA_GUPTA JG JG IS TABLE ALIAS NAME 
/
SELECT * FROM EMPP_DEPT
SELECT * FROM DEPT_TEST
/
SELECT EMP_NAME,EMP_SALARY,DEPT_NAME FROM EMPP_DEPT,DEPT_TEST
WHERE EMPP_DEPT.DEPT_ID = DEPT_TEST.DEPT_ID;
/
BUT USE THE ALIAS
/
SELECT EMP_NAME,EMP_SALARY,DEPT_NAME FROM EMPP_DEPT E,DEPT_TEST D
WHERE E.DEPT_ID = D.DEPT_ID;

JOIN
----
INNER JOIN
INNER JOIN RETURN ONLY THOSE ROWS THAT HAVE A MATCH IN BOTH JOIN TABLES.
SYNTAX
SELECT COLUMN_LIST FROM TABLE1 INNER JOIN TABLE2 
ON TABLE1.COLUMN_NAME=TABLE2.COLUMN_NAME
/
SELECT * FROM EMPP_DEPT
SELECT * FROM DEPT_TEST
/
DESCRIBE EMP_DEPT;
DESCRIBE DEPT_TEST;
/
SELECT E.EMP_ID, E.EMP_NAME, D.DEPT_NAME
FROM EMP_DEPT E
INNER JOIN DEPT_TEST D ON E.DEPT=D.DEPT_ID;
/
LEFT JOIN 
---------
THE LEFT JOIN COMMAND RETURNS ALL ROWS FROM THE LEFT TABLE, AND THE MATCHING ROWS FROM THE RIGHT TABLE
THE RESULT IS NULL FROM THE RIGHT SIDE IF THERE IS NO MATCH.
/
SYNTAX
------
SELECT COLUMN_LIST
FROM TABLE1
LEFT JOIN TABLE2
ON TABLE1.COLUMN_NAME=TABLE2.COLUMN_NAME
/
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY, D.DEPT_NAME
FROM EMP_DEPT E
LEFT JOIN DEPT_TEST D ON E.DEPT = D.DEPT_ID;
/
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY, D.DEPT_NAME
FROM EMP_DEPT E
LEFT JOIN DEPT_TEST D ON TO_NUMBER(E.DEPT) = D.DEPT_ID;
/
RIGHT JOIN 
---------
THE RIGHT JOIN COMMAND RETURNS ALL ROWS FROM THE RIGHT TABLE, AND THE MATCHING ROWS FROM THE LEFT TABLE
THE RESULT IS NULL FROM THE LEFT SIDE IF THERE IS NO MATCH.
/
SYNTAX
------
SELECT COLUMN_LIST
FROM TABLE1
RIGHT JOIN TABLE2
ON TABLE1.COLUMN_NAME=TABLE2.COLUMN_NAME
/
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY, D.DEPT_NAME
FROM EMP_DEPT E
RIGHT JOIN DEPT_TEST D ON E.DEPT = D.DEPT_ID;
/
FULL JOIN 
=========
A FULL JOIN RETURNS ALL THE ROWS FROM THE JOINED TABLES, WHETHER THEY ARE MATCHED OR NOT

YOU CAN SAY A FULL JOIN COMBINES THE FUNCTIONS OF A LEFT JOIN AND A RIGHT JOIN

FULL JOIN IS A TYPE OF OUTER JOIN THATS WHY IT IS ALSO REFERRED AS FULL OUTER JOIN.
/
SYNTAX
------
SELECT COLUMN_LIST
FROM TABLE1
FULL JOIN TABLE2
ON TABLE1.COLUMN_NAME=TABLE2.COLUMN_NAME
/
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY, D.DEPT_NAME
FROM EMP_DEPT E
FULL JOIN DEPT_TEST D ON E.DEPT = D.DEPT_ID;
/
CROSS JOIN 
==========
THE CROSS JOIN SPECIFYIES THAT ALL ROWS FROM FIRST TABLE JOIN WITH ALL OF THE ROWS OF SECOND TABLE

SYNTAX
------
SELECT COLUMN_LIST
FROM TABLE1
CROSS JOIN TABLE2
/
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY, D.DEPT_NAME
FROM EMP_DEPT E
CROSS JOIN DEPT_TEST D;
/
DESC EMP_DEPT
/
NATURAL JOIN
============
COMPARE ALL COMMON COLUMNS IN BOTH TABLE AND RETURN ALL MATCH RECORD.
SYNTAX
------
SELECT COLUMN_LIS FROM TABLE1
NATURAL JOIN TABLE2
/
SELECT E.EMP_ID, E.EMP_NAME, E.SALARY, D.DEPT_NAME
FROM EMP_DEPT E
NATURAL JOIN DEPT_TEST D;
/
SELF JOIN
=========
A SELF JOIN IS A JOIN IN WHICH A TABLE IS JOINED WITH ITSELF
 IT IS EK APNE JAISE EK TEMPORARAY TABLE CREATE KRTE HAI
SYNTAX
-------
SELECT COLUMN_LIST
FROM TABLE T1,TABLE T2
WHERE CONDITION;
/
SELECT E1.EMP_ID, E2.EMP_NAME, E1.SALARY
FROM EMP_DEPT E1,EMP_DEPT E2
WHERE E1.EMP_ID=E2.EMP_ID;
/
SELECT E1.EMP_ID, E2.EMP_NAME, E1.SALARY
FROM EMP_DEPT E1 INNER JOIN EMP_DEPT E2
ON E1.EMP_ID=E2.EMP_ID;
/
TABLESPACE AND DATAFILES  -- TABLESPACE IS COLLEECTIN OF DATAFILES
------------------------
THE ORACLE DATABASE STORES LOGICALLY IN TABLESPACES AND PHYSICALLY IN DATA FILE

TABLESPACE
. CAN BELONG TO ONLY ONE DATABASE
. CONSIST OF ONE OR MORE DATA FILES
. ARE FURTHER DIVIDED INTO LOGICAL UNITS OS STORAGE

DATAFILES
. CAN BELONG TO ONLY ONE TABLESPACE AND ONE DATABASE
. ALL DATA STORE UNDER THE DATA FILE PHYSICALLY.
/
SELECT TABLESPACE_NAME FROM USER_TABLESPACES;
/
SELECT TABLESPACE_NAME , FILE_NAME,BYTES FROM DBA_DATA_FILES;
/
CREATE TABLESPACE TEST DATAFILE 'C:\oraclexe\app\oracle\oradata\xe\test1.dbf'
size 50m;
/
drop TABLESPACE test;
/
TABLESPACE,USERS AND ROLE
=========================
CREATE TABLESPACE
. CREATE TABLESPACE TABLESPACENAME DATAFILE'PATH\DATAFILENAME.DBF' SIZE;
/
CREATE USER
. CREATE USER USERNAME IDENTIFY BY PASSWORD
. DEFAULT TABLESPACE TABLESPACENAME
. TEMPORARY TABLESPACE TEMP
. QUOTA UNLIMITED ON TABLESPACENAME;
/
CREATE ROLE
-----
CREATE ROLE ROLENAME;
/
PERMISSION TO ROLE
. GRANT CREATE TABLE,CREATE SESSION TO ROLENAME;
/
ASSIGN ROLE TO USER
. GRANT ROLENAME TO USERNAME;
/

WORK
====
CREATE TABLESPACE TEST DATAFILE 'C:\oraclexe\app\oracle\oradata\xe\test1.dbf' SIZE 50M;
/
CREATE USER JITENDRA IDENTIFIED BY JITENDRA
DEFAULT TABLESPACE TEST
TEMPORARY TABLESPACE TEMP
QUOTA UNLIMITED ON TEST;
/
CREATE ROLE DEMO;
/
GRANT CREATE TABLE,CREATE SESSION TO DEMO;
/
GRANT DEMO TO JITENDRA;
/
ALTER TABLESPACE
================
ALTER TABLESPACE STATEMENT CHANGES THE DESCRIPTION OF A TABLE SPACE AT THE CURRENT SERVER.
/
KISI  BHI TABLE ME EXISTING TABLE KO MODIFY KR SKTE HAI
/
SELECT TABLESPACE_NAME FROM DBA_DATA_FILES;
/
SELECT TABLESPACE_NAME,FILE_NAME,BYTES FROM DBA_DATA_FILES;
/
CREATE TABLESPACE TEST DATAFILE 'C:\oraclexe\app\oracle\oradata\xe\test1.dbf'
SIZE 50M;
/
ALTER TABLESPACE TEST ADD DATAFILE 'C:\oraclexe\app\oracle\oradata\xe\test1.dbf' SIZE 40M;
/
ALTER TABLE STATEMENT
---------------------
THE ALTER TABLE STATEMENT IS USED TO ADD,DELETE OR MODIFY COLUMNS IN AN EXISTING TABLE.
. THE ALTER TABLE STATEMENT IS ALSO USED TO ADD AND DROP VARIOUS CONSTRAINTS ON AN EXISTING TABLE.
/
SELECT * FROM EMP_DEPT;
/
SELECT * FROM EMPP_DEPT;
SELECT * FROM DEPT_TEST
/
ALTER TABLE EMPP_DEPT ADD EMP_ADDRESS VARCHAR2(50);
/
ALTER TABLE EMPP_DEPT RENAME COLUMN EMP_ADDRESS TO ADDRESS;
/
ALTER TABLE EMPP_DEPT MODIFY  ADDRESS NUMBER;
/
ALTER TABLE EMPP_DEPT MODIFY ADDRESS NUMBER  UNIQUE;
/
REFRENTIAL INTEGRITY
====================
. REFRENTIAL INTEGRITY REFERS TO THE ACCURACY AND CONSISTENCY OF DAT WITHIN A RELATIONSHIP.
. IN RELATIONSHIP,DATA IS LIKED BETWEEN TWO OR MORE TABLES.
. THIS IS ACHIEVED BY HAVING YHE FOREIGN KEY(IN THE ASSOCIATE TABLE) REFERENCE A PRIMARY
KEY VALUE (IN THE PRIMARY-OR PARENT TABLE).
/
CREATE TABLE DEPT_JITU(
DEPT_ID NUMBER PRIMARY KEY,
DEPT_NAME VARCHAR2(20));
/
INSERT INTO DEPT_JITU VALUES(1,'IT');
INSERT INTO DEPT_JITU VALUES(2,'HR');
INSERT INTO DEPT_JITU VALUES(3,'MEDICAL');
INSERT INTO DEPT_JITU VALUES(4,'QUALITY');
/
SELECT * FROM DEPT_JITU;
/
CREATE TABLE EMP_JITU (
EMP_ID NUMBER PRIMARY KEY,
EMP_NAME VARCHAR2(20),
EMP_SALARY DECIMAL(10,2),
DEPT_ID NUMBER REFERENCES DEPT_JITU ON DELETE CASCADE
);
/
INSERT INTO EMP_JITU VALUES (1,'JITU',80000,1);
INSERT INTO EMP_JITU VALUES (2,'JITU JITU',80000,5);
/
GROUP BY CLAUSE
===============
. THE GROUP BY CLAUSE IS USED TO GROUP ROWS THAT HAVE THE SAME VALUES
. THE GROUP BY CLAUSE IS USED IN THE SELECT STATEMENT
. OPTINALLY IT IS USED IN CONJUNCTION WITH AGGREGATE FUNCTIONS TO PRODUCE SUMMARY REPORTS FROM THE DATABASE.
SYNTAX
------
SELECT COLUMN_NAME
FROM TABLE_NAME
GROUP BY COLUMN_NAME;
SYNTAX
------
SELECT COLUMN_NAME
FROM TABLE_NAME
GROUP BY COLUMN_NAME;
/
SELECT * FROM EMPP_DEPT;
SELECT * FROM DEPT_TEST;
/
select Pro-name from products group by pro_name
/
Aggregate Functions
-------------------
oracle aggregate functions calculate on a group of rows and return a single value for each group
we commanly use the aggregate functions together with the group by clouse
the group by CLOUSE DIVIDES THE ROWS INTO GROUPS AND AN AGGREGATE FUNCTIOS
CALCULATES AND RETURN A SINGLE RESULTS FOR EACH GROUP.
. COUNT -- RETURN THE NUMBER OF ROW IN THE COLUMN
. MIN -- RETURN THE MINIMUM OF RANGE OF VALUES
. MAX -- RETURN THE MAXIMUM OF RANGE OF VALUES
. AVG -- RETURN THE AVERAGE OF RANGE OF VALUES 
. STDDEV -- RETURN THE STANDARS DEVIATION OF THE RANGE OF VALUES
VARIANCE -- RETURN THE VARIANCE OF RANGE OF VALUES
. SUM -- RETURN THE SUM OF RANGE OF VALUES
/
SELECT * FROM EMPP_DEPT;

SELECT COUNT(*) FROM EMPP_DEPT
/
SELECT VARIANCE (EMP_SALARY) FROM EMPP_DEPT;
/
SELECT EMP_SALARY,COUNT(*) FROM EMPP_DEPT GROUP BY EMP_SALARY;
/
HAVING CLOUSE
=============
HAVING CLOUSE IS USED WITH GROUP BY CLOUSE TO RESTRICT THE GROUPS OF RETURNED ROW WHERE CONDITION IS TRUE

SELECT * FROM PRODUCT;

SELECT PRO_NAME ,COUT(*)FROM PRTODUCTS
GROUP BY PRO_NAME HAVING COUNT(*) > 2;
/
CHARACTER FUNCTION 
=================
 A CHARACTER FUNCTION IS A FUNCTION THA TAKES ONE OR MORE CHARACTER VALUES AS 
 PARAMETER AND RETURNS EITHER A CHARACTER VALUE OR A NUMBER VALUE.
 /
 TWO TYEPS OF CHARACTER FUNCTION 
 1. CASE CONVERSION FUNCTION 
   . LOWER
   . UPPER
   . INITCAP
/
2. CHARACTER MANUPULATION FUNCTION
  . CONCAT
  . SUBSTR
  . LENGTH
  . INSTR
  . LPAD | RPAD
  . TRIM
  . REPLACE
/
SELECT * FROM EMPP_DEPT;
/
SELECT UPPER(EMP_NAME) FROM EMPP_DEPT
SELECT INITCAP(EMP_NAME) FROM EMPP_DEPT
SELECT LOWER(EMP_NAME) FROM EMPP_DEPT
/
SELECT CONCAT(EMP_NAME,EMP_SALARY) FROM EMPP_DEPT;
SELECT SUBSTR('I AM JITENDRA' ,3,2) FROM EMPP_DEPT
SELECT LENGTH('I AM JITENDRA') FROM EMPP_DEPT
SELECT INSTR('I AM JITENDRA','JITENDRA') FROM DUAL
SELECT LPAD('JITENDRA',3) FROM DUAL
SELECT TRIM(' JITENDRA ') FROM DUAL
SELECT REPLACE('123JITENDRA','123') FROM DUAL
/
NUMBERIC FUNCTION 
-----------------
THE ORACLE NUMBERIC FUNCTION TAKE INPUT AS AN EXPRESSION AND RETURN NUMBERIC VALUES
SELECT CEIL(12.3) FROM DUAL --CEIL(N)
SELECT FLOOR(127.3) FROM DUAL --FLOOR(N)
SELECT ROUND(579.34886,3) FROM DUAL --ROUN(N,M)
SELECT POWER(5,3) FROM DUAL --POWER(M,N)
SELECT MOD(9,5) FROM DUAL --MOD(M,N)
SELECT MOD(10,5) FROM DUAL
SELECT MOD(6,7) FROM DUAL
--RETURN THE REMAINDER OF THE DIVISION OF M BY N.
N=0,THEN 0 IS RETURN.IF N>M,THEN M IS RETURNED.
SELECT SORT(9) FROM DUAL --SORT(N)
SELECT ABS(-29) FROM DUAL -- ABS(N)
/
SELECT TRUNC(29.16,1),TRUNC(31.2,-1) FROM DUAL --TRUNC(N1,N2)
 . RETURN A VALUES WITH THE REQUIRED NUMBER OF DECIMAL PLACES WHILE A NGATIVE N2
  ROUNDS TO THE LEFT OF THE DECIMAL.
/

CONVERSION FUNCTION
===================
CONVERT A VALUE (OF ANY TYPE) INTO A SPECIFIED DATATYPE
1. TO_DATE CONVERTS A STRING INTO A DATE FORMATE.
2. TO_CHAR CONVERT EITHER A NUMBER OR A DATE VALUE TO A STRING VALUE
3. NVL ALLOW YOU TO REPLACE A NULL VALUE WITH ANOTHER VALUE
4. DECODE USE TO EXPEND SMALL ABBREVIATION
/
CREATE TABLE EMPLOYES_JITU(
EMP_ID NUMBER PRIMARY KEY,
EMP_NAME VARCHAR2(20),
EMP_SALARY DECIMAL(10,2),
JOIN_DATE DATE,
COUNTRY VARCHAR(50));
/
INSERT INTO EMPLOYES_JITU VALUES(1,'AHMAD',5000,'1-JAN-2020','INDIA');
INSERT INTO EMPLOYES_JITU VALUES(2,'JITU',50000,TO_DATE('2020-MARCH-1','YYYY-MM-DD'),'AUS');
INSERT INTO EMPLOYES_JITU VALUES(3,'JITENDRA',55000,'1-JAN-2020','US');
INSERT INTO EMPLOYES_JITU VALUES(4,'AHMAD',50500,'1-JAN-2020','PAK');
INSERT INTO EMPLOYES_JITU VALUES(5,'AHMAD',50100,'1-JAN-2020','LON');
/
SELECT * FROM EMPLOYES_JITU;
/
SELECT EMP_NAME,TO_CHAR(JOIN_DATE,'MM') FROM EMPLOYES_JITU;
SELECT EMP_NAME,NVL(EMP_SALARY,5000) FROM EMPLOYES_JITU;
SELECT EMP_NAME,DECODE(COUNTRY,'PAK','PAKISTAN') FROM EMPLOYES_JITU;
/
SQL COMMAND TYPES
=================
DATA DEFINITION LANGUAGE (DDL) USE TO DEFINE THE DATABASE,LIKE
1. CREATE
2. DROP
3. TRUNCATE
4.ALTER
5.BAKUPDATABASE

DATA MANIPULATION LANGUAGE (DML) USE THE MANIPULATE THE DATA PRESENT IN THE DATABASE ,LIKE
1. USE
2. INSERT
3. UPDATE
4. DELETE
5. SELECT
APART FROM THESE COMMANDS THE ALSO OTHER MANIPULATE OPERATORS/FUNCTIONS SUCH AS 
1. OPERATORS
2. AGGREGATE FUNCTION
3. NULL FUNCTION
4. ALIASES & CASE STATEMENT

DATA CONTROL LANGUAGE (DCL)
DEALS WITH THE USER PERMISSIONS AND CONTROLS OF THE DATABASE SYSTEM
1. PRIVILEGENAME-IS THE PRIVILEGE/RIGHT/ACCESS GRANTED TO USER
2. OBJECTNAME-NAME OF A DATABASE OBJECT LIKE TABLE/VIEW/STORED PROC.
3. USERNAME NAME OF THE USER WHO IS GIVEN THE ACCESS/RIGHT/PRIVILEGES
4. PUBLIC - TO GRANT ACCESS RIGHT TO ALL USERS
5. ROLENAME-THE NAME OF A SET OF PRIVILEGES GROUPED TOGETHER
6. WITH GRANT OPTION-TO GIVE THE USER ACCESS TO GRANT OTHER USERS WITH RIGHTS

TRANSACTION CONTROL LANGUAGE
1. COMMIT
2. ROLLBACK
3.SAVEPOINT

NOT NULL CONSTRAINT
-------------------
CREATE TABLE STUDENT_JITU (STD_ID NUMBER,STD_NAME VARCHAR2(20) NOT NULL);
INSERT INTO STUDENT_JITU VALUES(1,'JITENDRA')
INSERT INTO STUDENT_JITU VALUES(2,'')
/
Error starting at line : 68 in command -
INSERT INTO STUDENT_JITU VALUES(2,'')
Error report -
ORA-01400: cannot insert NULL into ("APPS"."STUDENT_JITU"."STD_NAME")
/
DESC STUDENT_JITU 
ERROR:
ORA-04043: object STUDENT_JITU does not exist
Name     Null?    Type         
-------- -------- ------------ 
STD_ID            NUMBER       
STD_NAME NOT NULL VARCHAR2(20)
/
UNIQUE CONSTRAINGT
==================
CREATE TABLE STUDENT_JITUS (STD_ID NUMBER,STD_NAME VARCHAR2(20) UNIQUE);
INSERT INTO STUDENT_JITUS VALUES(1,'JITENDRA')
INSERT INTO STUDENT_JITUS VALUES(3,'JITENDRA')
/
PRIMARY KEY FOREIGN KEY CONSTRAINTS
===================================
KISI BHI TABLE ME ROW AND COLUMN 
UNIQUE IDENTIFY KRNE KE LIYE USED HOTA HAI 
PRIMARY KEY IS  NULL NHI HOTI HAI
PRIMARY KEY ONLY ONE TABLE DEFINE
/ FORIEGN KEY IS REFER TO MORE TABLE
FORIEGN KEY ONE  YA MORE TABLE DEFINE
/
CREATE TABLE DEPARTMENT_JITUS (DEPT_ID NUMBER PRIMARY KEY ,
DEPT_NAME VARCHAR2(20));
/
DESC DEPARTMENT_JITUS
Name         Null?    Type          
------------ -------- ------------- 
DEPARTMENTID NOT NULL NUMBER        
MANAGER               VARCHAR2(100) 
EMPLOYEEID            NUMBER 
/
CREATE TABLE STUDENTS_JIT (STD_ID NUMBER PRIMARY KEY,
STD_NAME VARCHAR2(20),
DEPT_ID NUMBER 
REFERENCES
DEPARTMENT_JITUS);
/
INSERT INTO DEPARTMENT_JITUS VALUES (2,'MEDICAL');
SELECT * FROM STUDENTS_JIT
/
INSERT INTO STUDENTS_JIT VALUES(1,'JITENDRA',1)
INSERT INTO STUDENTS_JIT VALUES(2'JITENDRA'3)
FOREIGN KEY DUPLICATE RECORD BHI INSERT HOTE HAI 
/
SEQUENCE IN ORACLE DATABAS
=========================
SYNTAX
CREATE SEQUENCE SCHEMA_NAME.SEQUENCE_NAME
[INCREMENT BY INTERVAL]
[START WITH FIRST_NUMBER]
[MAXVALUEN MAX_VALUE | MAXVALUE]
[MINVALUEN MIN_VALUE | MAXVALUE]
[CYCLE | NOCYCLE]
[CACHE CACHE_ZIZE | NOCACHE]
[ORDER | NOORDER];
/
CREATE TABLE STUDT (STD_ID NUMBER PRIMARY KEY,STD_NAME VARCHAR2(20));
CREATE SEQUENCE DTD_SEQ INCREMENT BY 1 START WITH 100
MAXVALUE 999 MINVALUE 1 NOCACHE NOORDER;
/
INSERT INTO STUDT VALUES(DTD_SEQ.NEXTVAL,'RAM');
SELECT DTD_SEQ.CURRVAL FROM STUDT
SELECT *FROM STUDT
/
PSEUDOCOLUMNS
--------------
. A PSEUDOCOLUMN BEHAVES LIKE A TABLE COLUMN,BUT IS NOT ACTUALLY STORED IN THE TABLE
. YOU CAN SELECT FROM PSEUDOCOLUMNS, BUT WE CAN NOT INSERT,UPDATE OR DELETE THEIR VALUES.
. USED TO GET THE SYSTEM-RELATED DATA
. HELPS US TO GET THE METADATA OF OUR DATABASE
. ALLOW US TO GET THE DETAILS OF ACCESS RIGHT ON OUR DATABASE
. HELPS US TO KEEP A CHECK ON OUR DATABASE

1. SYSDATE -RETURN THE CURRENT SYSTEM DATE.
2. SYSTIMESTAMP -RETURN THE CURRENT SYSTEM DATE WITH TIME MILLISECOND AND AM,PM ETC.
3. UID -RETURN CURRENT USER ID
4. USER -RETURN CURRENT USER DETAILS
5. ROWID -RETURN THE ROWID (BINARY ADDRESS) OF A ROW IN A DATABASE TABLE
6. CURRVAL -CURRENT VALUE
7. NEXTVAL -NEXT VALUE

/
SELECT SYSDATE FROM DUAL;
SELECT SYSTIMESTAMP FROM DUAL;
SELECT UID FROM DUAL
SELECT USER FROM DUAL
SELECT ROWID FROM EMPLOYEE;
SELECT ROWNUM FROM EMPLOYEE
SELECT ROWNUM,EMP_NAME FROM EMPLOYEE WHERE ROWNUM <3;
/
SUBQUERY,INNER QUERY OR NESTED QUERY -- CALLED THESE THREE
====================================
. A SUBQUERY IS A QUERY WITHIN A QUERY
. USE FOR TO SELECT RECORDS WHERE WE DO NOT KNOW THE CONDITION VALUES
. MOSTLY WE ARE USING AFTER WHER CLOUSE BUT WE CAN USE WITH FROM AND SELECT CLOUSE
. ORACLE ALLOWS UP TO 255 LEVELS OF SUBQUERIES IN THE WHERE CLOUSE
/
SELECT * FROM EMPLOYEE
/
SELECT * FROM EMPLOYEE 
WHERE SALARY =(SELECT MAX (SALARY) FROM EMPLOYEE);
/ 
 SELECT * FROM EMPLOYEEN WHERE SALARY=(SELECT MIN(SALARY) FROM EMPLOYEE);
 /
SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT SALARY FROM  EMPLOYEE WHERE SALARY >30000);
/
SELECT EMP_NAME FROM EMPLOYEE WHERE SALARY IN (SELECT SALARY FROM  EMPLOYEE WHERE SALARY >30000);


DATA DICTIONARY
=================
. THE ORACLE DATA DICTIONARY IS ONE OF THE MOST IMPORTANT OF THE ORACLE DBMS.
. IT CONTAINS ALL INFORMATION ABOUT THE STRUCTURES AND OBJECTS OF THE DATABASE SUCH AS 
-TAB
-ALL TABLE
-ALL SEQUENCES
ALL VIEWS
ALL CONSTRAINTS
. THE DATA STORED IN THE DATA DICTIONARY ARE ALSO OFTEN CALLED METADATA.

SELECT * FROM TAB
SELECT * FROM ALL_TABLES
SELECT * FROM ALL_SEQUENCES;
SELECT * FROM ALL_VIEWS
SELECT * FROM ALL_INDEXES
SELECT * FROM ALL_CONSTRAINTS
/
EXCUTE COMMANDS WRITTEN IN NOTEPAD FILE
=======================================
SELECT * FROM EMPLOYEE
START C:\Users\jngup\Desktop\Hyd Study\EMPLOYEE.SQL;
/
REPORTS
=======
SELECT * FROM EMPLOYEE
/
SET PAGESIZE 10
SET LINE SIZE 150
SET PAUSE ON
SET 'PRESS ANY KEY ...'
TTITLE LEFT 'EMPLOYEE REPORT'
BTITLE LEFT 'END REPORT'
COLUMN EMP_NAME FORMAT A5 TRUNC
SELECT * FROM EMPLOYEE;
CLEAR COLUMN
TTITLE OFF
SET PAUSE OFF
SET LINESIZE80
SET PAGESIZE 24
/
VIEWS IN ORACLE
===============
SELECT * FROM EMPLOYEE
/
CREATE VIEW EMPLOYEE_VIEW_JITU AS SELECT * FROM EMPLOYEE 

/
CREATE VIEW EEMP_VIEW AS SELECT EMP_NAME,SALARY FROM EMPLOYEE 
CREATE OR REPLACE VIEW EMPLOYEE_VIEW_JITU AS SELECT * FROM EMPLOYEE
IINSERT INTO EMPLOYEE_VIEW_JITU VLAUES(1.'JITU',...)

CREATE OR REPLACE VIEW EMPLOYEE_VIEW_JITU AS SELECT * FROM EMPLOYEE WHERE SALARY =50000 WITH CHECK OPTION;

DROP VIEW EMPLOYEE_VIEW_JITU
/
INPUT VARIABLE
==============
SELECT * FROM EMPLOYEE
ACCEPT ENAME CHAR PROMPT 'PLEASE ENTER EMPLOYEE NAME:'
/
SELECT * FROM EMPLOYEE WHERE EMP_NAME='&ENAME';
/
DEFINE VARIABLE
===============
SELECT * FROM EMPLOYEE
DEFINE EID =101;
SELECT * FROM EMPLOYEE WHERE EMP_ID='&EID'
/
DEFINE
/
UNDEFINE EID;


PL/SQL
======
. PL/SQL (PROCEDURAL LANGUAGE EXTENSION OS SQL)
. SQL IS THE STANDARD DATABASE LANGUAGE AND PL/SQL IS STRONGLY INTEGRATED WITH SQL
select * from dual;
/
. PL/SQL SUPPORTS BOTH STATIC AND DYNAMIC SQL.
. PL/SQL ALLOW SENDING AND ENTIRE BLOCK OF STATEMENTS TO THE DATABASE AT ONE TIME.
. PL/SQL SAVES TIME ON DESIGN AND DEBUGGING BY STRONG FEATURE AS EXCEPTION HANDLING
,ENCAPSULATION,DATA HIDING AND OBJECT-ORIENTED DATA TYPES.
. PL/SQL PROVIDES HIGH SECUIRITY LEVEL
. PL/SQL PROVIDE ACCESS TO PREDEFINED SQL PACKAGES
. IT OFFER A VARIETY OF PROGRAMMING STRUCTURES
. IT SUPPORTS STRUCTURED PROGRAMMING THROUGH FUNCTION AND PROCEDURES
. IT SUPPORTS OBJECT-ORIENTED PROGRAMMING
. IT SUPPORTS THE DEVELOPMENT OF WEB APPLICATIONS AND SERVER PAGES

PL/SQL BLOCK AND SYNTAX
=======================

DECLARE
     <DECLARATIONS SECTION>

BEGIN
    <EXECUTABLE COMMANDS> DIFFERENT SQL QUERY PROC SB HOTE HAI

EXCEPTION
    <EXCEPTION HANDLING>
    
END;

-------------------------------------------
DECLARE
   MESSAGE VARCHAR2(50);
BEGIN 
MESSAGE:='WELCOME TO JITU';
DBMS_OUTPUT.PUT_LINE(MESSAGE);
END;

SET SERVEROUTPUT ON;
/
SELECT * FROM EMPLOYEE;
/
DECLARE 
NAME EMPLOYEE.EMP_NAME%TYPE;
SALARY_S EMPLOYEE.SALARY%TYPE;
MSG NUMBER;
BEGIN
SELECT EMP_NAME,SALARY INTO NAME,SALARY_S FROM EMPLOYEE WHERE EMP_ID=&MSG;
DBMS_OUTPUT.PUT_LINE(NAME);
DBMS_OUTPUT.PUT_LINE(SALARY_S);
END;

/
DECLARE 
    NAME EMPLOYEE.EMP_NAME%TYPE;
    SALARY_S EMPLOYEE.SALARY%TYPE;
    MSG EMPLOYEE.EMP_ID%TYPE;
BEGIN
    MSG := &MSG; -- Assuming MSG is the employee ID, and you want to assign a value to it.
    SELECT EMP_NAME, SALARY 
    INTO NAME, SALARY_S 
    FROM EMPLOYEE 
    WHERE EMP_ID = MSG;

    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || NAME);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || SALARY_S);
END;
/
IF ELSE STATEMENT
================
DECLARE
E_SALES NUMBER :=50000;
E_COMMISSION NUMBER :=0;
BEGIN
IF E_SALES > 40000 THEN
E_COMMISSION :=(E_SALES*10/100);
DBMS_OUTPUT.PUT_LINE('YOUR COMMISSION IS 10% EQUAL TO: || E_COMMISSION');
END IF;
END;
/
SET SERVEROUTPUT ON;
/
DECLARE 
    NAME EMPLOYEE.EMP_NAME%TYPE;
    SALARY_S EMPLOYEE.SALARY%TYPE;
    MSG EMPLOYEE.EMP_ID%TYPE;
BEGIN
    MSG := &MSG; -- Assuming MSG is the employee ID, and you want to assign a value to it.
    SELECT EMP_NAME, SALARY 
    INTO NAME, SALARY_S 
    FROM EMPLOYEE 
    WHERE EMP_ID = MSG;

    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || NAME);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || SALARY_S);
END;
/
IF ELSE STATEMENT
================
DECLARE
E_SALES NUMBER :=30000;
E_COMMISSION NUMBER :=0;
BEGIN
IF E_SALES > 40000 THEN
E_COMMISSION :=(E_SALES*10)/100;
DBMS_OUTPUT.PUT_LINE('YOUR COMMISSION IS 10% EQUAL TO :' || E_COMMISSION);
ELSE
DBMS_OUTPUT.PUT_LINE('YOUR COMMISSION IS 2% EQUAL TO :' || (E_SALES*2)/100);
END IF;
END;
/


DECLARE
E_SALES NUMBER :=35000;
E_COMMISSION NUMBER :=0;
BEGIN
IF E_SALES > 40000 THEN
E_COMMISSION :=(E_SALES*10)/100;
DBMS_OUTPUT.PUT_LINE('YOUR COMMISSION IS 10% EQUAL TO :' || E_COMMISSION);
ELSIF E_SALES <=40000 AND E_SALES >30000 THEN
E_COMMISSION:=(E_SALES*5)/100;
DBMS_OUTPUT.PUT_LINE('YOUR COMMISSION IS 5% EQUAL TO :' || E_COMMISSION);
ELSE
DBMS_OUTPUT.PUT_LINE('YOUR COMMISSION IS 2% EQUAL TO :' || (E_SALES*2)/100);
END IF;
END;
/
SET SERVEROUTPUT ON;
/
BASIC LOOP
==========
. BASIC LOOP EXECUTE STATEMENTS UNTIL CONDITION IS MET
. THE BODY OF LOOP MUST CONTAINS AT LEAST ONE EXIT OR EXIT WHEN STATEMENT FOR TERMINATING THE LOOP.

SYNTAX
------
<<LABEL>>LOOP
STATEMENTS;
END LOOP LOOP_LABEL;
/
DECLARE
I NUMBER :=0;
BEGIN
LOOP
I :=I+1;
EXIT WHEN I >10;
DBMS_OUTPUT.PUT_LINE('VALUE OF I :' ||I);
END LOOP;
END;

SET SERVEROUTPUT ON;
/
DECLARE
I NUMBER :=0;
BEGIN
LOOP
I :=I+1;
IF  I > 10 THEN
EXIT;
END IF;
DBMS_OUTPUT.PUT_LINE('VALUE OF I :' ||I);
END LOOP;
END;
/
DECLARE
I NUMBER :=0;
J NUMBER :=0;
BEGIN
<<OUTER_LOOP>> LOOP
I:=I+1;
EXIT OUTER_LOOP WHEN I>2;
DBMS_OUTPUT.PUT_LINE('OUTER LOOP :' ||I);
J :=0;
<<INNER_LOOP>>LOOP
J :=J+1;
EXIT INNER_LOOP WHEN J>3;
DBMS_OUTPUT.PUT_LINE('INNER LOOP :' ||J);
END LOOP INNER_LOOP;
END LOOP OUTER_LOOP;
END;
/
WHILE LOOP
==========
. WHILE LOOP EXECUTE ONE OR MORE STATEMENTS WHILE A CONDITION IS TRUE.

SYNTAX
-------
WHILE CONDITION

LOOP

STATEMENTS;

END LOOP;

/
DECLARE
I NUMBER := 1;
BEGIN
WHILE I<=10
LOOP
DBMS_OUTPUT.PUT_LINE('VALUE OF I :' ||I);
I :=I+1;
END LOOP;
END;
/
DECLARE
I NUMBER := 1;
BEGIN
WHILE I<=10
LOOP
DBMS_OUTPUT.PUT_LINE('VALUE OF I :' ||I);
I :=I+1;
EXIT WHEN I=3;
END LOOP;
END;
/
DECLARE
VAR1 NUMBER;
VAR2 NUMBER;
BEGIN
VAR1:=200;
VAR2:=1;
WHILE VAR2<=10
LOOP
DBMS_OUTPUT.PUT_LINE(VAR1*VAR2);
VAR2 :=VAR2+1;
END LOOP;
END;
/
FOR LOOP
========
. FOR LOOP EXECUTE STATEMENTS FOR A PREDETERMINED NUMBER OF TIME

SYNTAX
------
FOR INDEX IN INITIAL_VALUE..FINAL_VALUE LOOP

LOOP STATEMENTS;

END LOOP;

/
BEGIN
FOR I IN 1..5 LOOP
DBMS_OUTPUT.PUT_LINE('VALUE OF I :'||I);
END LOOP;
END;
/
BEGIN
FOR I IN 1..100 LOOP
DBMS_OUTPUT.PUT_LINE('VALUE OF I :'||I);
END LOOP;
END;
/
DECLARE
VAR1 NUMBER;
BEGIN
VAR1:=100;
FOR VAR2 IN 1..10 LOOP
DBMS_OUTPUT.PUT_LINE(VAR1*VAR2);
END LOOP;
END;
/
SELECT * FROM EMPLOYEE;
/
BEGIN 
FOR E IN (SELECT * FROM EMPLOYEE) LOOP
IF E.SALARY =8900 THEN
DBMS_OUTPUT.PUT_LINE('ID:'||E.EMP_ID||',NAME:'||E.EMP_NAME||',SALARTY:'||E.SALARY);
END IF;
END LOOP;
END;
/
PL/SQL CURSOR
=============
. WHEN AN SQL STATEMENT IS PROCESSED, ORACLE CREATE A MEMORY AREA KNOWN AS CONTEXT AREA.
. A CURSOR IS A POINTER TO THIS CONTEXT AREA.
. IT CONTAINS ALL INFORMATION NEEDED FOR PROCESSING THE STATEMENT
. IN PL/SQL THE CONTEXT AREA IS CONTROLLED BY CURSOR
. A CURSOR CONTAINS INFORMATION ON A SELECT STATEMENT AND THE ROWS OF DATA ACCESSED BY IT
. CURSOR USE FOR PROCCESSING ROW-BY-ROW

TWO TYPES CURSOR
---------------
IMPLICIT CURSOR
EXPLICIT CURSOR

CURSOR ATTRIBUTES
-------------------
TO WORK WITH THE CURSOR WHETHER IMPLICIT OR EXPLICIT CURSOR,THERE ARE FOLLOWING ATTRIBUTES WHICH ARE USED

ATTRIBUTE NAME            DESCRIPTION 
--------------            -----------

1. %ISOPEN -  IF CURSOR IS OPEN IT RETURN A BOOLEAN VALUE TRUE OTHERWISE IT RETURNS BOOLEAN VALUE FALSE
2. %FOUND - IF RECORDS FETCHED BY CURSOR WAS SUCCESSFUL IT RETURNS BOOLEAN VALUE TRUE OTHERWISE IT RETURNS BOOLEAN VALUE FALSE
3. %NOTFOUND - IF RECORDS FETCHED BY CURSOR WAS UNSUCCESSFUL IT RETURNS BOOLEAN VALUE TRUE OTHERWISE IT RETURNS BOOLEAN VALUE FALSE
4. %ROWFOUND - IT RETURNS THE NUMBER OF ROW AFFECTED BY PL/SQL STATEMENT
PL/SQL IMPLICIT CURSORS
======================
. THE IMPLICIT CURSORS ARE AUTOMATICALLY CREATED BY ORACLE WHILE AN SQL STATEMENTS IS CXECUTED
. THESE ARE CREATED BY DEFAULT TO PROCESS THE STATEMENTS WHEN DML STATEMENTS LIKE INSERT,UPDATE,DELETE ETC ARE EXECUTED
/
SELECT * FROM EMPLOYEE
/
DECLARE
TOTAL_ROWS NUMBER;
BEGIN
UPDATE EMPLOYEE SET SALARY=SALARY + 5000;
IF SQL%NOTFOUND THEN
DBMS_OUTPUT.PUT_LINE('RECORD NOT UPDATED');
ELSIF SQL%FOUND THEN
TOTAL_ROWS:=SQL%ROWCOUNT;
DBMS_OUTPUT.PUT_LINE('TOTAL ROWS UPDATED:'|| TOTAL_ROWS);
END IF;
END;

SET SERVEROUTPUT ON;
/
PL/SQL EXPLICIT CURSOR
======================
. THE EXPLICIT CURSOR ARE DEFINED BY THE PROGRAMMERS TO GAIN MORE CONTROL OVER
THE CONTEXT AREA.
. THESE CURSOR SHOULD BE DEFINE IN THE DECLARATION SECTION OF THE PL/SQL BLOCK
. IT IS CREATE ON A SELECT STATEMENT WHICH RETURNS MORE THAN ONE ROW

FOLLOWING IS THE SYNTAX TO CREATE AN EXPLICIT CURSOR

STEPS
YOU MUST FOLLOW THESE STEP WHILE WORKING WITH AN EXPLICIT CURSOR
1. DECLARE THE CURSOR TO INITIALIZE IN THE MEMORY
2. OPEN THE CURSOR TO ALLOCATE MEMORY
3. FETCH THE CURSOR TO RETRIVE DATA
4. CLOSE THE CURSOR TO RELEASE ALLOCATED MEMORY

1.DECLARE TGHE CURSOR
------------------
IT DEFINE THE CURSOR WITH A NAME AND THE ASSOCIATED SELECT STATEMENT

SYNTAX FOR EXPLICIT CURSOR DECLARATION
1. CURSOR NAME IS
2. SELECT STATEMENT;

2. OPEN THE CURSOR:
==================
IT IS USED ALLOCATE MEMORY FOR THE CURSOR AND MAKE IT EASY TO FETCH THE 
ROWS RETURNED BY THE SQL STATEMENTS INTO IT

SYNTAX FOR CURSOR OPEN:
1. OPEN CURSOR_NAME;

3. IT IS USED TO ACCESS ONE AT A TIME. YOU CAN FETCH ROWS FROM THE ABOVE-OPENED CURSOR
AS FOLLOWS

SYNTAX FOR CURSOR FETCH:

1. FETCH CURSOR_NAME INTO VARIABLE_LIST;

4. CLOSE THE CURSOR
===================

IT IS USED TO THE ALLOCATED MEMORY. THE FOLLOWING SYNTAX IS USED TO CLOSE 
THE ABOVE-OPEN CURSOR.

SYNTAX FOR CURSOR CLOSE
1. CLOSE CURSOR_NAME;
/
SELECT * FROM EMPLOYEE
/
DECLARE
E_ID EMPLOYEE.EMP_ID%TYPE;
E_NAME EMPLOYEE.EMP_NAME%TYPE;
E_SALARY EMPLOYEE.SALARY%TYPE;
CURSOR E_EMPLOYEE IS 
SELECT EMP_ID,EMP_NAME,SALARY FROM EMPLOYEE;
BEGIN
OPEN
E_EMPLOYEE;
LOOP
FETCH E_EMPLOYEE INTO E_ID,E_NAME,E_SALARY;
EXIT WHEN E_EMPLOYEE%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(E_ID||':'||E_NAME||':'||E_SALARY);
END LOOP;
CLOSE E_EMPLOYEE;
END;
/
SET SERVEROUTPUT ON;
/

TRIGGERS
========
. TRIGGER ARE STORED PROGRAMS
. WHICH AUTOMATICALLY EXECUTE OR FIRED (BEFORE/AFTER) OCCURENCE OF SOME EVENTS

EVENT ARE:
1. A DATABASE MANIPULATION (DML) STATEMENT (DELETE,INSERT,OR UPDATE)
2. A DATABASE DEFINITION(DDL) (CREATE,ALTER OR DROP)
3. A DATABASE OPERATION (SERVERERROR,LOGON,STARTUP OR SHUTDOWN)
/
SELECT * FROM EMPLOYEE 
 /
 CREATE TABLE NEW_EMPLOYEE
 (
 ID NUMBER,
 SALARY DECIMAL (10,2),
 MESSAGE VARCHAR2(100)
 );
/
CREATE TRIGGER TRIGGER_EMP
AFTER UPDATE OF SALARY ON EMPLOYEE
FOR EACH ROW 
BEGIN
INSERT INTO NEW_EMPLOYEE(ID,SALARY,MESSAGE)
VALUES(:OLD.EMP_ID,:NEW.SALARY,'RECORD IS UPDATED');
END;
/
UPDATE EMPLOYEE SET
SALARY=1000
WHERE EMPL_ID=101;
/
UPDATE EMPLOYEE SET
SALARY=1000
WHERE EMP_ID=101;
/
SELECT * FROM NEW_EMPLOYEE
/
PL/SQL PROCEDURE
================
. PROCEDURE IS A PL/SQL BLOCK WHICH PERFORM ONE OR MORE SPECIFIC TASKS
. PROCEDURE IS MAINLY CREATED TO PERFORM ONE OR MORE DML OPERATION OVER DATABASE
. IT IS NOT MANDATORY TO RETURN THE VALUE.

SYNTAX
------

CREATE [OR REPLACE] PROCEDURE PROCEDURE_NAME
[(PARAMETER_NAME [IN | OUT | IN OUT])] TYPE [.....])
{IS|AS}
BEGIN
<PROCEDURE_BODY>
END PROCEDURE_NAME;
/
CREATE OR REPLACE PROCEDURE WELCOME
AS
BEGIN
DBMS_OUTPUT.PUT_LINE('WELCOME');
END;
/
BEGIN
WELCOME;
END;

SET SERVEROUTPUT ON;
/
SELECT * FROM DEPT_TEST;
/
CREATE OR REPLACE PROCEDURE INSERT_DEPT(
DEPT_ID IN NUMBER,DEPT_NAME IN VARCHAR2)
IS
BEGIN
INSERT INTO DEPT_TEST VALUES(DEPT_ID,DEPT_NAME);
END;
/
BEGIN
INSERT_DEPT(6,'RECEPTION');
END;
/
SELECT * FROM EMPP_DEPT;
/
CREATE OR REPLACE PROCEDURE UPDATE_EMP(
ID IN NUMBER,AMOUNT IN NUMBER,D OUT NUMBER)
IS
BEGIN
UPDATE EMPP_DEPT SET EMP_SALARY=EMP_SALARY + AMOUNT
WHERE EMP_ID=ID;
SELECT EMP_SALARY INTO D FROM EMPP_DEPT WHERE EMP_ID=ID;
DBMS_OUTPUT.PUT_LINE(D);
END;
/
BEGIN 
UPDATE_EMP();
END;
/
VARIABLE K NUMBER;
EXECUTE UPDATE_EMP(1,40000,:K);
/
PL/SQL FUNCTION
===============

. THE PL/SQL FUNCTION IS VERY SIMILAR TO PL/SQL PROCEDURE, BUT A FUNCTION MUST ALWAYS RETURN A VALUE
. USE RETURN TO THE VALUE
. RETURN DATATYPE IS MANDATORY THE TIME OF CREATION
. USED MAINLY TO PERFORM SOME CALCULATION

/
SYNTAX
------
CREATE [OR REPLACE] FUNCTION FUNCTION_NAME
[(PARAMETER_NAME [IN | IN OUT])] TYPE[...])
RETURN RETURN_DATATYPE
{IS|AS}
BEGIN
<FUNCTION_BODY>
END FUNCTION_NAME;
/
CREATE OR REPLACE FUNCTION ADD_NUMBER(
N1 IN NUMBER,N2 IN NUMBER
)
RETURN NUMBER
IS 
N3 NUMBER;
BEGIN
 N3:=N1+N2;
 RETURN N3;
END;
/
CALL TO FUNCTION
/
DECLARE
N3 NUMBER;
BEGIN
N3:=ADD_NUMBER(50,20);
DBMS_OUTPUT.PUT_LINE('ADDITION IS :' || N3);
END;
SET SERVEROUTPUT ON;
/
SELECT * FROM EMPP_DEPT;
/
CREATE OR REPLACE FUNCTION UPDATE_SAL(
ID IN NUMBER,AMOUNT IN NUMBER)
RETURN NUMBER
IS
D NUMBER
BEGIN
UPDATE EMPP_DEPT SET EMP_SALARY=EMP_SALARY+AMOUNT
WHERE EMP_ID =ID;
SELECT EMP_SALARY INTO D FROM EMPP_DEPT WHERE EMP_ID=ID;
DBMS_OUTPUT
END;
-------------------------
SET SERVEROUTPUT ON;
/
SELECT * FROM EMPP_DEPT;
/
CREATE OR REPLACE FUNCTION UPDATE_SAL(
ID IN NUMBER,AMOUNT IN NUMBER)
RETURN NUMBER
IS
D NUMBER
BEGIN
UPDATE EMPP_DEPT SET EMP_SALARY=EMP_SALARY+AMOUNT
WHERE EMP_ID =ID;
SELECT EMP_SALARY INTO D FROM EMPP_DEPT WHERE EMP_ID=ID;
DBMS_OUTPUT
END;
/
DECLARE
D NUMBER
D:=UPDATE_SAL(3,10000);
END;
/
PL/SQL EXCEPTION HANDLING
========================

. AN ERROR OCCURS DURING THE PROGRAM EXECUTION IS CALLED EXCEPTION IN PL/SQL

THERE ARE TWO TYPES OF EXCEPTION:
. PRE-DEFINED EXCEPTIONS
. USER-DEFINED EXCEPTION

PRE-DEFINED EXCEPTIONS
----------------------
. THERE ARE MANY PRE-DEFINED EXCEPTION IN PL/SQL WHICH ARE EXECUTED WHEN 
ANY DATABASE RULE IS VIOLATE BY THE PROGRAMS

SYNTAX
------
DECLARE
  <DECLARATION SECTION>
BEGIN
  <EXECUTABLE COMMAND(S)>
EXCEPTION
  <EXCEPTION HANDLING GOES HERE>
  WHEN EXCEPTION1 THEN
   EXCEPTION1-HANDLING-STATEMENTS
  WHEN EXCEPTION2 THEN
   EXCEPTION2-HANDLING-STATEMENTS
  WHEN EXCEPTION3 THEN
   EXCEPTION3-HANDLING-STATEMENTS
   .
   .
   .
   WHEN OTHERS THEN 
   EXCEPTION3-HANDLING-STATEMENTE
   END;
   
PRE-DEFINED EXCEPTION

GOOGLE KARO

/
SELECT * FROM EMPP_DEPT 
/
DECLARE
E_ID EMPP_DEPT.EMP_ID%TYPE;
E_NAME EMPP_DEPT.EMP_NAME%TYPE;
BEGIN
SELECT EMP_NAME INTO  E_NAME FROM EMPP_DEPT WHERE EMP_ID=&E_ID;
DBMS_OUTPUT.PUT_LINE(E_NAME);
END;

SET SERVEROUTPUT ON;
/
DECLARE
E_ID EMPP_DEPT.EMP_ID%TYPE;
E_NAME EMPP_DEPT.EMP_NAME%TYPE;
BEGIN
SELECT EMP_NAME INTO  E_NAME FROM EMPP_DEPT WHERE EMP_ID=&E_ID;
DBMS_OUTPUT.PUT_LINE(E_NAME);
END;
 --
 Error report -
ORA-01403: no data found
ORA-06512: at line 5
01403. 00000 -  "no data found"
*Cause:    No data was found from the objects.
*Action:   There was no data from the objects which may be due to end of fetch.
/
DECLARE
E_ID EMPP_DEPT.EMP_ID%TYPE;
E_NAME EMPP_DEPT.EMP_NAME%TYPE;
BEGIN
SELECT EMP_NAME INTO  E_NAME FROM EMPP_DEPT WHERE EMP_ID=&E_ID;
DBMS_OUTPUT.PUT_LINE(E_NAME);
EXCEPTION WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND');
END;
/
EK SE JYDA EXCEPTION KO DEFINE
OTHERS HAI JO KI KUCH NHI HAI KOI OR ECEPTOIN RAISED KR RHE HO
/

DECLARE
E_ID EMPP_DEPT.EMP_ID%TYPE;
E_NAME EMPP_DEPT.EMP_NAME%TYPE;
BEGIN
SELECT EMP_NAME INTO  E_NAME FROM EMPP_DEPT WHERE EMP_ID=&E_ID;
DBMS_OUTPUT.PUT_LINE(E_NAME);
EXCEPTION WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND');
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('ERROR!');
END;
/
RAISING EXCEPTIONS
==================

. ALL THE PREDEFINED EXCEPTION ARE RAISED IMPLICITY WHENEVER THE ERROR
OCCURS
. USER-DEFINED EXCEPTION NEEDS TO BE RAISED EXPLICITY
. THIS CAN BE ACHIEVED USING THE KEYWORD 'RAISE'. THIS CAN BE USED IN ANY OF THE
WAYS MENTIONED BELOW

SYNTAX
------
DECLARE
 EXCEPTION_NAME EXCEPTION;
BEGIN
IF CONDITION THEN 
RAISE EXCEPTION_NAME;
END IF;
EXCEPTION
WHEN EXCETION_NAME THEN
END;
/
DECLARE
N NUMBER :=&N;
EX_INVALID EXCEPTION;
BEGIN
IF N>=5 THEN
RAISE EX_INVALID;
ELSE
DBMS_OUTPUT.PUT_LINE('N IS LESS THEN 5');
END IF;
EXCEPTION WHEN EX_INVALID THEN
DBMS_OUTPUT.PUT_LINE('N IS GRATER THEN 5');
END;
/
USER-DEFINED EXCEPTION
======================
. PL/SQL FACILITIES THEIR USER TO DEFINE THEIR OWN EXCEPTION ACCORDING TO THE NEED
OF THE PROGRAM.
. A USER-DEFINED EXCEPTION CAN BE RAISED EXPLICITY,USING EITHER A RAISE STATEMENTS
OR THE PROCEDURE DBMS_STANDARD.RAISE_APPLICATION_ERROR.

SYNTAX
-----
DECLARE
<EXCEPTION_NAME > EXCEPTION;
BEGIN
<EXECUTION BLOCK>
EXCEPTION
WHEN
<EXCEPTION_NAME>
THEN
<HANDLER>
END;
/
EMPP_DEPT
/

DECLARE
E_ID EMPP_DEPT.EMP_ID%TYPE:=&E_ID;
E_NAME EMPP_DEPT.EMP_NAME%TYPE;
EX_INVALID EXCEPTION;
BEGIN
IF E_ID<=0 THEN
RAISE EX_INVALID;
ELSE
SELECT EMP_NAME INTO E_NAME FROM EMPP_DEPT WHERE EMP_ID=E_ID;
DBMS_OUTPUT.PUT_LINE(E_NAME);
END IF;
EXCEPTION WHEN EX_INVALID THEN
DBMS_OUTPUT.PUT_LINE('ID MUST BE GREATER THAN ZERO');
END;
/
DECLARE
E_ID EMPP_DEPT.EMP_ID%TYPE:=&E_ID;
E_NAME EMPP_DEPT.EMP_NAME%TYPE;
EX_INVALID EXCEPTION;
BEGIN
IF E_ID<=0 THEN
RAISE EX_INVALID;
ELSE
SELECT EMP_NAME INTO E_NAME FROM EMPP_DEPT WHERE EMP_ID=E_ID;
DBMS_OUTPUT.PUT_LINE(E_NAME);
END IF;
EXCEPTION WHEN EX_INVALID THEN
DBMS_OUTPUT.PUT_LINE('ID MUST BE GREATER THAN ZERO');
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('NO SUCH EMPP_DEPT');
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('ERROR!');
END;
/
PL/SQL PACKAGE
==============
. PACKAGE IS A SCHEMA OBJECT THAT CONTAINS DEFINITIONS FOR A GROUP OF RELATED FUNTIONALITIES
. PACKAGE INCLUDES VARIABLE,CONTANTS,CURSORS,EXCEPTION,PROCEDURES AND FUNCTIONS
. PACKAGE IS COMPILED AND STORED AS A DATABASE OBJECT THAT CAN BE USED LATER

COMPONENTS OF PACKAGE
---------------------
. PACKAGE SPECIFICATION
. PACKAGE BODY

PACKAGE SPECIFICATION
---------------------

PACKAGE SPECIFICATION CONSISTS OF AS ALL THE PUBLIC VARIABLES,CURSORS.,OBJECTS,
PROCEDURE, FUNCTIONS AND EXCEPTION.

SYNTAX
------
CREATE [OR REPLACE] PACKAGE <PACKAGE_NAME>

IS

<SUB_PROGRAM AND PUBLIC ELEMENT DECLARATION>

END <PACKAGE_NAME>
/
PACKAGE BODY
============

. IT CONSIST OF THE DEFINITION OF ALL THE ELEMENTS THAT 
ARE PRESENT IN THE PACKAGE SPECIFICATION.
/
SYNTAX
------
CREATE [OR REPLACE] PACKAGE BODY

<PACKAGE_NAME>

IS

<GLOBAL_DECLARATION PART>

<PRIVATE ELEMENT AND PUBLIC ELEMENT DEFINITION>

.

<PACKAGE INITIALIZATION>
END <PACKAGE_NAME>
/
/
SELECT * FROM EMPP_DEPT;
/
SELECT * FROM DEPT_TEST;
/
CREATE OR REPLACE PACKAGE PACKAGE_DEPT
AS
PROCEDURE INSERT_DEPT (DEPT_ID IN NUMBER,DEPT_NMAE IN VARCHAR2);
PROCEDURE DELETE_DEPT(DELETE_ID IN NUMBER);
FUNCTION ADD_NUMBER(N1 IN NUMBER,N2 IN NUMBER)
RETURN NUMBER;
END;
/
DEFINE THE PACKAGE

CREATE OR REPLACE PACKAGE PACKAGE_DEPT
AS
PROCEDURE INSERT_DEPT (DEPT_ID IN NUMBER,DEPT_NMAE IN VARCHAR2)
IS
BEGIN
INSERT INTO DEPT_TEST VALUES (DEPT_ID,DEPT_NAME);
END INSERT_DEPT;
PROCEDURE DELETE_DEPT(DELETE_ID IN NUMBER)
IS
BEGIN
DELETE FROM DEPT_TEST WHERE DEPT_ID=DELETE_ID;
END DELETE_DEPT;
FUNCTION ADD_NUMBER (N1 IN NUMBER,N2 IN NUMBER)
RETURN NUMBER
IS
N3  NUMBER;
BEGIN
N3:=N1+N2;
RETURN N3;
END ADD_NUMBER;
END PACKAGE_DEPT;
/

BEGIN
PACKAGE_DEPT.INSERT_DEPT(7,'MANAGMENT')
END;

SET SERVEROUTPUT ON;

SELECT * FROM DEPT_TEST
/
BEGIN
PACKAGE_DEPT.DELETE_DEPT(7);
DBMS_OUTPUT.PUT_LINE('RECORD DELETED');
END;
---------------------------------------------------------
CREATE OR REPLACE PACKAGE PACKAGE_DEPT AS
    PROCEDURE INSERT_DEPT (DEPT_ID IN NUMBER, DEPT_NAME IN VARCHAR2);
    PROCEDURE DELETE_DEPT(DELETE_ID IN NUMBER);
    FUNCTION ADD_NUMBER (N1 IN NUMBER, N2 IN NUMBER) RETURN NUMBER;
END PACKAGE_DEPT;
/

CREATE OR REPLACE PACKAGE BODY PACKAGE_DEPT AS
    PROCEDURE INSERT_DEPT (DEPT_ID IN NUMBER, DEPT_NAME IN VARCHAR2) IS
    BEGIN
        INSERT INTO DEPT_TEST (DEPT_ID, DEPT_NAME) VALUES (DEPT_ID, DEPT_NAME);
    END INSERT_DEPT;

    PROCEDURE DELETE_DEPT(DELETE_ID IN NUMBER) IS
    BEGIN
        DELETE FROM DEPT_TEST WHERE DEPT_ID = DELETE_ID;
    END DELETE_DEPT;

    FUNCTION ADD_NUMBER (N1 IN NUMBER, N2 IN NUMBER) RETURN NUMBER IS
        N3  NUMBER;
    BEGIN
        N3 := N1 + N2;
        RETURN N3;
    END ADD_NUMBER;
END PACKAGE_DEPT;
/
BEGIN
PACKAGE_DEPT.INSERT_DEPT(7,'MANAGMENT')
END;

SET SERVEROUTPUT ON;

SELECT * FROM DEPT_TEST
/
BEGIN
PACKAGE_DEPT.DELETE_DEPT(7);
DBMS_OUTPUT.PUT_LINE('RECORD DELETED');
END;
